---
title: 'Lab Two: Describing and Visualizing Data'
author:
 - Alex Davis
 - Cody Adams
output: pdf_document
---

This lab discusses the basics of exploring, describing, and visualizing data. The following packages are required for this lab: 

1. car
2. dplyr
3. reshape2
4. modeest
5. descr
6. psych

__Reminder:__ Lab one introduced how to install packages via _install.packages()_ function. __Note:__ These packages should already be installed from the class initialization script.

The installed packages require loading at the beginning of a R session.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#setwd("~/Methods Labs/Lab 2")
ds <- read.csv("Class Data Set Factored.csv", header = TRUE)
library(car)
library(dplyr)
library(reshape2)
library(modeest)
library(descr)
library(psych)
```

## Part I: Factoring

The previous lab introduced several types of objects in R. For the purpose of this lab, objects are classified in two broad groups: factors and numeric.

Factors are nominal data that a label is applied to.
 - e.g., race, gender, party identification, etc. 

Numerics are data consisting of numbers, where it is ranked (ordinal and interval). 

When data is read into R (e.g., importing csv file), R automatically classifies the data by type. When data is recognized as non-numeric, R will classify it as a factor.

In the class dataset, the variable _f.party.2_ is a variable consisting of factors that identifies the party affilation of the individuals who answered a survey. The _table()_ function describes the variable by category.

```{r factor1, echo=TRUE}
table(ds$f.party.2)
```

Attempting to take mean of the _f.party.2_ variable inevitably fails.

```{r mean, echo=TRUE}
mean(ds$f.party.2)
```

Party affiliation is nominal data that cannot be described via mean. Consequently, R will error when attempting to calculate the mean or median of factor variables. 

The _str()_ function describes the structure of the _f.party.2_ variable:

```{r structure, echo=TRUE}
str(ds$f.party.2)
```

The _f.party.2_ variable is a factor with three levels: "Dem", "Ind", and "Rep."

With many data sets, data are initially coded in numbers and factored afterwards. For example, the _party_ variable in the _ds_ data set is numeric:

```{r numeric, echo=TRUE}
table(ds$party)
```

Without a codebook to decipher the numeric values, statistician are incapable of explaining what 1, 2, 3, or 4 represent within the _ds_ data set. Factoring data remedies this issue. Factoring data in R serves two broad purposes:

1. Applies labels to data
2. Tells R to treat the data as categorical/nominal

At a very basic level, a variable can be factored without applying labels. At minimum, R will treat the data as categorical. This method is sufficient when a variable requires quick factoring. The basic syntax is to use the _factor()_ function. __Note:__ Best practice for factoring an existing variable is to create a variable within the same data set. Best practice suggests to append the new variable with _f._ to indicate the variable is factored.

```{r fac1, echo=TRUE}
ds$f.gender <- factor(ds$gender)
```

__Reminder:__ The $ sign instructs R what data set to draw the variable from, or to tell R what data set to assign the new factored variable to. The new factored variable can be described via the _table()_ function.

```{r fac2, echo=TRUE}
table(ds$f.gender)
```

While this factored variable is split into two categories, it is not apparent which numbers represent male and female. Labels should be assigned to the numbers to clarify the relationship between the numbers and their meaning. When factoring a variable, R requires the number of levels within the variable and the corresponding labels. In the _f.gender_ variable there are two levels, 0 and 1, that require woman and men labels.

```{r fac3, echo=TRUE}
ds$f.gender <- factor(ds$gender, levels = c(0,1), labels = c("Women", "Men"))
table(ds$f.gender)
```

The vector function, _c()_, instructs R the levels and labels of the variable.

The _f.party_ variable should also be factored, where 1 = Dem, 2 = Rep, 3 = Ind, and 4 = Other, then create a table of the variable.

```{r fac4, echo=TRUE}
ds$f.party <- factor(ds$party, levels = c(1,2,3,4), labels = c("Dem", "Rep", "Ind", "Other"))
table(ds$f.party)
```

The structure of the _f.party_ variable describes a factor with four levels.

```{r fac5, echo=TRUE}
str(ds$f.party)
```

There are other types of data conversions as well. In most cases, the basic syntax is the same as the _factor()_ function, except the function names are _numeric()_ or _integer()_. __Note:__ For most purposes, numeric and integer are the same.

### Coerce Factoring

Sometimes the typical commands do not work and variables must be coerced. When a variable is coerced, R is instructed to treat the variable as if it were a different object type. The coercive functions are:

1. _as.factor()_
2. _as.numeric()_
3. _as.integer()_

__Try it!__ Convert a factor variable into a numeric variable using the _numeric()_ function.

```{r num, echo=TRUE}

```

This fails, so the coerce function should be employed.

```{r num2, echo=TRUE}
ds$n.party <- as.numeric(ds$f.party)
```

Examine the new variable with the _table()_ and _str()_ functions.

```{r num3, echo=TRUE}
table(ds$n.party)
str(ds$n.party)
```

## Part II: Recoding

In R, the _recode()_ function recodes values within a variable. There are several broad purposes to recode a variable, including:

1. To correct or change incorrect data.
2. To restructure data, making it easier for calculations.
3. To emphasize some intended effect.

For example, a recode is necessary to look at age groups instead of exact ages. If everyone in the survey reported their exact age (e.g., 54, 23, etc.) and age groups is necessary (e.g., 18-25, 26-35, etc.) the _recode()_ function is useful.

To perform a recode, follow this basic syntax: _recoded.variable <- recode(old.variable, "recode commands")_

Performing a recode is best demonstrated via example. The best practice for recoding variables suggest creating a new variable with a _r._ prefix. 

Within the class data set is an _ideol_ variable describing ideology. Currently the ideology variable goes from 1 to 7, with 1 being very liberal and 7 being very conservative. The ideology variable can be recoded from seven levels to three, liberal, moderate, and conservative, via the _recode()_ function. Values from 1 to 2 will recode as 1, 3 to 5 will recode as 2, and 6 to 7 will recode as 3. The _recode()_ function is provided by the _car_ package. 

```{r recode1, echo=TRUE}
ds$r.ideol <- car::recode(ds$ideol, "1:2=1; 3:5=2; 6:7=3; else=NA; NA=NA")
```

The _table()_ function describes the result of recoding the _ideol_ variable.

```{r recode2, echo=TRUE}
table(ds$r.ideol, useNA = "always")
```

__Note:__ _else=NA; NA=NA_ is included at the end of the recode function. This instructs R to regard any other responses, whether missing data or data that for some reason is outside the original range, as NA, and to treat all existing NAs as NAs. Sometimes _-99=-99_ or _-99=NA_ requires inclusion in the function as well. 

__Note:__ In the recode function, all the recode arguments are required __inside one set of quotation marks__. Each argument is separated with a semicolon. R will generate an error message if commas are used. 

Using colons to define ranges will save time. In the _recode()_ function, using _3:5=1_ instructs R to recode all values between 3 and 5 to a 2. This is the preferred method opposed to typing _3=2;4=2;5=2;_.

There is no standard method to categorize or recode data. Let the research question, model design, and data determine the best approach to recoding. For example, surveys that ask individuals to support something on a scale of 1 to 4, with 1 as very supportive and 4 as least supportive, perhaps recoding the higher value to indicate greater support is appropriate.
Now let's look at our race variable:

```{r race, echo=TRUE}
table(ds$race)
```

In the _ds_ data set, the _race_ variable consists of codes: 1 for Caucasian, 2 for African-American, and 3 through 7 for a variety of other races (Native American, Asian, Pacific Islander, 2+ races, and Other).

__Try it!__ Recode this variable to go from 7 levels to 3, where 1 is still Caucasian, 2 is African American, and 3 includes all others. 

```{r race2, echo=TRUE}
ds$r.race <- car::recode(ds$race, "1=1; 2=2; 3:7=3; else=NA; NA=NA")
table(ds$r.race)
```

### Factoring and Recoding

Factoring a variable is generally easier subsequent to recoding. Given the _race_ variable now consists of 3 levels instead of 7, factoring will add meaningful words in place of the values. The values 1, 2, and 3 can be factored as White, African-American, and Other, respectively.

```{r race3, echo=TRUE}
ds$f.race.2 <- factor(ds$r.race, levels = c(1,2,3), labels = c("White", "African-American", "Other"))
table(ds$f.race.2)
```

The same can be done with the _ideol_ variable. The values 1, 2, and 3 can be factored as Liberal, Moderate, and Conservative, respectively.

```{r ideol, echo=TRUE}
ds$f.ideol <- factor(ds$r.ideol, levels = c(1,2,3), labels = c("Liberal", "Moderate", "Conservative"))
table(ds$f.ideol)
```

### Creating a Dummy Variable

Factoring and recoding permit the creation of dummy variables. A dummy variable is a binary indicator (0 or 1) of some category, to test for an effect from a particular category. Dummy variables are prominent in political science, so it is imperative to understand how to create and use them.

A dummy variable will be created with the recoded _race_ variable to indicate whether the respondent identified as African-American (1) or not (0). Recall that in the _r.race_ variable, African-American is coded as 2.

```{r dummy1, echo=TRUE}
ds$r.AfAm <- car::recode(ds$r.race, "2=1; else=0; NA=NA")
table(ds$r.AfAm)
```

The newly created dummy variable will now be factored to apply meaningful labels in place of the numbers.

```{r dummy2, echo=TRUE}
ds$f.AfAm <- factor(ds$r.AfAm, levels=c(0,1), labels = c("Non African-American", "African-American"))
table(ds$f.AfAm)
```

## Part III: Building and Sorting Your Data

In R, random data can be generated easily into objects, and manipulated as desired. There are a variety of methods to accomplish this, of which the basics are explored below. 

The _rnorm()_ function generates _n_ random values that fit a normal distribution, given a mean and standard deviation.

```{r norm, echo=TRUE}
one <- rnorm(100, mean=3)
two <- rnorm(100, mean=7)
three <- rnorm(100, mean=1)
```

The previous code created three objects consisting of 100 random values with different means. The three objects can be combined into a single column using the _cbind()_ function. The _cbind()_ function will combine the  given objects sequentially in a column in the provided order. 

```{r cbind, echo=TRUE}
four <- cbind(one, two, three)
```

Alternatively, the _rbind()_ function can combine the three objects into a single row. Similar to the _cbind()_ function, the _rbind()_ function will combine the given objects sequentially in the provided order. 

```{r rbind, echo=TRUE}
five <- rbind(one, two, three)
```

### Apply functions

In R, there is a family of _apply()_ functions. The _apply()_ functions provide a way of sorting through and examining data. The _apply()_ function to examine the objects created. Provided is the basic syntax: _apply(X, margin, fun...)_.

This instructs R to return a function (e.g., mean, sum, etc.) on an object for a margin (1 for rows, 2 for columns).

The _apply()_ function can return the mean for each column in the object _four_. 

```{r apply1, echo=TRUE}
apply(four, 2, mean)
```

Similarly the _apply()_ function can return the same mean from the object _five_. Recall that the _five_ object was created using the _rbind()_ function, so the values of the original objects were transposed to create the _five_ object. In this case, the _apply()_ function should return the mean of a row rather than a column. 

```{r apply2, echo=TRUE}
apply(five, 1, mean)
```
Other functions are possible with _apply()_. The following tutorial on _apply()_ is a great resource: 
https://www.datacamp.com/community/tutorials/r-tutorial-apply-family

Two derivatives of the _apply()_ function exist: _sapply()_ and _tapply()_. 

The _sapply()_ function can provide the mean of lists within an object. The _six_ object contains two lists, a and b, populated with specified values.

```{r sapply1, echo=TRUE}
six <- list(a=1:10, b=11:20)
```

Using _sapply()_ we can view the mean of each list within the _six_ object.

```{r sapply2, echo=TRUE}
sapply(six, mean)
```

The _sapply()_ function is useful for vectors and matrices.

The tapply() function explores data by specific parameters. Using the _tapply()_ function, a breakdown of age and ideology can be explored. 

```{r tapply, echo=TRUE}
tapply(ds$age, ds$ideol, summary)
```

__Note:__ The _tapply()_ function includes a _summary_ argument. The _summary_ argument returns a lot of information about ideology and age. The _tapply()_ function can provide specific information about variables. For example, the mean age of each ideology score. 

```{r tapply2, echo=TRUE}
tapply(ds$age, ds$ideol, mean)
```

### Other Methods of Exploring Your Data

R provides multiple methods of accomplishing an objective. Just as _tapply()_ will provide a breakdown of ideology by age, the _by()_ function is an equivalent alternative.

```{r by1, echo=TRUE}
by(ds$age, ds$ideol, summary)
```

__Note:__ The _by()_ function results are essentially the same as the _tapply()_ function results. The relationship of age and gender can be further examined with the _by()_ function to return the mean age per gender.

```{r by2, echo=TRUE}
by(ds$age, ds$gend, mean)
```

Recall that the _gend_ variable was previously factored with meaningful words rather than numbers.

```{r by3, echo=TRUE}
by(ds$age, ds$f.gend, mean)
```

The _filter()_ function will filter out all the data except specified parameters into a new data set. Using the _filter()_ function, data associated to men in the data set can be examined.

Best practice suggests naming variables associated to the filter employed. Filtering for men within the data set suggests a name of _ds.men_ for the new variable.

```{r filter1, echo=TRUE}
ds.men <- filter(ds, ds$gender==1)
```

The _ds.men_ data set can be refined further to men over 30 years old. The _filter()_ function accepts multiple arguments, as follows.

```{r filter2, echo=TRUE}
ds.men30 <- filter(ds, ds$gender==1 & ds$age > 30)
```


The _summary()_ function provides a breakdown of the new _ds.men30_ variable by ideology. 

```{r filter3, echo=TRUE}
summary(ds.men30$ideol)
```

Another method to filter data is the _slice()_ function. The _slice()_ function will filter data by rows. For example, the first 100 rows of the _ds_ data set.

```{r slice1, echo=TRUE}
ds100 <- slice(ds, 1:100)
```

### Subset Data

Another method to breakdown  data is to subset. This is similar to _filter()_ function. One difference is the _subset()_ argument is included in R, whereas the _dplyr_ package is required for _filter()_. A men subset of _ds_ data set is created as the _men.ds_ object.

```{r subset, echo=TRUE}
men.ds <- subset(ds, gender==1)
```

Data can be subset by specific columns via names or column numbers.

```{r subset2, echo=TRUE}
ds.sub1 <- subset(ds, select = c(party:glbcc_risk))
ds.sub2 <- subset(ds, select = c(1:15))
```

Data can also be subset by specific variables.

Boolean operators assist with building data subsets in R:

1. < less than
2. <= less than or equal to
3. >  greater than
4. >= greater than or equal to
5. == exactly equal to
6. != not equal to 
7. ! not (example: !x - pronounced "not x" )
8. | Or (example: x | y - pronounced "x OR y") 
9. & And (example: x & y - pronounced "x AND y") 

## Part IV: Working with Nominal Data

Often times data is nominal. This is data that does not necessarily have a numeric value, but rather is categorized by a word or label (e.g., race, political party, etc.). The factored _party_ variable is an example.

```{r nom1, echo=TRUE}
table(ds$f.party)
```

If analyzing the data, the "Other" category does not explain much. In this case, recoding the Other responses as NA will exclude Other from summaries.

```{r nom2, echo=TRUE}
ds$f.party.2 <- car::recode(ds$f.party, "'Dem'='Dem'; 'Rep'='Rep' ;'Ind'='Ind' ;'Other'=NA;
							else=NA;NA=NA")
table(ds$f.party.2)
```

__Note:__ When recoding a factored variable, label names must be in in apostrophe marks __within the quotation marks__.

### Finding the Mode

When working with nominal data, there are some inapplicable statistics. For example, the mean for the factored political party variable does not exist. However, finding the mode for nominal data is useful. Recall from mathematics that the mode is the value, or in this case the label, that occurs the most often. 

In R, the _modeest_ package provides the _mlv()_ function to return the mode for data ta set. __Note:__ The mlv() package does not work for factored variables. To accommodate this limitation, the factored variable can be coerced to a number using the _as.integer()_ function.

```{r mode1,echo=TRUE}
mlv(as.integer(ds$f.party.2), na.rm = TRUE)
```

The modal value is 3, which corresponds with the third nominal variable that can be checked via the _table()_ function.

```{r mode2, echo=TRUE}
table(ds$f.party.2)
```

The _table()_ function returns 3 as corresponding to Republican, so Republican is the modal value. 

Another method to find the mode is to make a table and sort the table by how often the labels occur. 

```{r mode3, echo=TRUE}
sort(table(ds$f.party.2), decreasing = TRUE)
```

The _freq()_ function returns the frequency of values.

```{r freq, echo=TRUE}
freq(ds$f.party.2, plot = FALSE)
```

The _freq()_ function returns the count in each group and proportions. To construct a table that shows the proportion breakdown only: first create a table of the variable then use prop.table() then multiply by 100.

```{r prop, echo=TRUE}
party.table <- table(ds$f.party.2)
party.table.per <- prop.table(party.table)*100
party.table.per
```

### Visualizing Nominal Data

R has nearly countless ways to visualize data. A simple method is a bar plot. 

Bar plots are great for visualizing nominal data. The _barplot()_ function will visualize an object. Using the _barplot()_ function, political party can be visualized.

```{r bar1, echo=TRUE}
barplot(table(ds$f.party.2))
```

Alternative to "table(ds$f.party.2)" inside the barplot function is using the previously created party.table object. Additionally, a legend and color will provide more value to the bar plot.

```{r bar2, echo=TRUE}
barplot(party.table, beside=TRUE, legend=rownames(party.table), col = c("Blue", "White", "Red"),
		ylab ="Frequency", main="Frequency of Respondents by Political Party")
```

The specific syntax needed to customize visualizations gets easier with time.

Recall the table created to show the proportion among respondents of political parties. To visualize the nominal data using the _barplot()_ function:

```{r bar3, echo=TRUE}
barplot(party.table.per, beside=TRUE, legend=rownames(party.table.per), col = c("Blue", "White", "Red"),
		ylab ="Percentage", main="Percentage of Respondents by Political Party")
```

## Part V: Working with Ordinal Data

Recall that ordinal data is data that is assigned numeric values, but on an ordered scale. An example of ordinal data is education level (e.g., some high school is higher than no high school, a high school diploma is higher than some high school, some college is higher than high school, etc). 

The _table()_ function describes the _education_ variable.

```{r ord, echo=TRUE}
table(ds$education)
```

The _education_ variable contains 8 categories on an ordered scale. Factoring the _education_ variable to apply labels will provide meaning to each value.

```{r ord2, echo=TRUE}
ds$f.education <- factor(ds$education, levels=c(1,2,3,4,5,6,7,8), 
				   labels=c("< HS","HS/GED","Vocational/Technical", "Some College",
							"2 year/Associates", "Bachelor's Degree", "Master's degree", "PhD/JD/MD")) 
table(ds$f.education, useNA = "always")
```

Using the _sort()_ function can return the modal education level.

```{r ord3, echo=TRUE}
sort(table(ds$f.education), decreasing = TRUE)
```

The _barplot()_ function will visualize education levels.

```{r ord4, echo=TRUE}
barplot(table(ds$f.education))
```

More detail is available via a table object and visualization.

```{r ord5, echo=TRUE}
educ.table <- table(ds$f.education)
barplot(educ.table, beside=TRUE, legend=rownames(educ.table), 
		col = c("#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd"),
		ylab ="Frequency", main="Frequency of Respondents by Education Level", 
		args.legend = list(title = "Education", x = "topright", cex = .7), ylim = c(0, 700))
```

__Note:__ The colors in the previous example are hexadecimal colors. Color schemes are available via the following website:

http://colorbrewer2.org/

## Part VI: Working with Interval Data

Interval data is similar to ordinal data, but with interval data the difference between levels is meaningful. For this section ordinal data is treated as interval data. The _glbcc\_risk_ variable in the _ds_ data set measures an individual's perception of the risk by global climate change on a scale of 0 to 10, where 0 is no risk and 10 is extreme risk.

The _psych_ package provides a _describe()_ function. The _describe()_ function is useful to examine variables.

```{r int, echo=TRUE}
describe(ds$glbcc_risk)
```

To find the modal value using the _mlv()_ function.

```{r int2, echo=TRUE}
mlv(ds$glbcc_risk, na.rm = TRUE)
```

The _mlv()_ function returns the modal value as 10.

A histogram is the appropriate visualization for interval data. Histograms returns values on a continuous scale as opposed to individual values. The _hist()_ function is provided by R to visualize interval data.


```{r hist, echo=TRUE}
hist(ds$glbcc_risk)
```

Alternatively, employing the _plot()_ function in conjunction with the _density()_ function will plot the density for interval data. Removing all missing values from a variable is necessary to view density. The _na.omit()_ function within the _density()_ function will remove all missing values.

```{r dens, echo=TRUE}
density.gcc <- density(na.omit(ds$glbcc_risk))
plot(density.gcc)
```

The _densityPlot()_ function in the _car_ package accomplishes the same result. Again, a density plot requires all missing values to be omitted.

```{r dens2, echo=TRUE}
densityPlot(na.omit(ds$glbcc_risk))
densityPlot(na.omit(ds$glbcc_risk), adjust = 25)
```
The first density plot uses default bin widths, and the second uses bin widths of 25.

Last, a box plot can be generated via the _boxplot()_ function.

```{r box, echo=TRUE}
boxplot(ds$glbcc_risk, xlab = "GCC Risk", main = "Percieved Risk of Global Climate Change")
```
