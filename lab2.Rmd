---
title: 'Lab Two: Describing and Visualizing Data'
author:
 - Alex Davis
 - Cody Adams
output: pdf_document
---

This lab discusses the basics of exploring, describing, and visualing data. The following packages are required for this lab: 

1. car
2. dplyr
3. reshape2
4. modeest
5. descr
6. psych

__Reminder:__ Lab one introduced how to install packages via _install.packages()_ function. __Note:__ These packages should already be installed from the class initialization script.

The installed packages require loading at the beginning of a R session.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#setwd("~/Methods Labs/Lab 2")
ds <- read.csv("Class Data Set Factored.csv", header = TRUE)
library(car)
library(dplyr)
library(reshape2)
library(modeest)
library(descr)
library(psych)
```

## Part I: Factoring

The previous lab introduced several types of objects in R. For the purpose of this lab, objects are classified in two broad groups: factors and numeric.

Factors are nominal data that a label is applied to.
 - e.g., race, gender, party identification, etc. 

Numerics are data consisting of numbers, where it is ranked (ordinal and interval). 

When data is read into R (e.g., importing csv file), R automatically classifies the data by type. When data is recognized as non-numeric, R will classify it as a factor.

In the class dataset, the variable _f.party.2_ is a variable consisting of factors that identifies the party affilation of the individuals who answered a survey. The _table()_ function describes the variable by category.

```{r factor1, echo=TRUE}
table(ds$f.party.2)
```

Attempting to take mean of the _f.party.2_ variable inevitably fails.

```{r mean, echo=TRUE}
mean(ds$f.party.2)
```

Party affiliation is nominal data that cannot be described via mean. Consequently, R will error when attempting to calculate the mean or median of factor variables. 

The _str()_ function describes structure of the _f.party.2_ variable:

```{r structure, echo=TRUE}
str(ds$f.party.2)
```

The _f.party.2_ variable is a factor with three levels: "Dem", "Ind", and "Rep."

With many data sets, data are initially coded in numbers and factored afterwards. For example, the _party_ variable in the _ds_ data set is numeric:

```{r numeric, echo=TRUE}
table(ds$party)
```

Without a codebook to decipher the numeric values, statistician are incapable of explaining what 1, 2, 3, or 4 represent within the _ds_ data set. Factoring data remedies this issue. Factoring data in R serves two broad purposes:

1. Applies labels to data
2. Tells R to treat the data as categorical/nominal

At a very basic level, a variable can be factored without applying labels. At minimum, R will treat the data as categorical. This method is sufficient when a variable requires quick factoring. The basic syntax is to use the _factor()_ function. __Note:__ Best practice for factoring an existing variable is to create a variable within the same data set. Best practice suggests to append the new variable with _f._ to indicate the variable is factored.

```{r fac1, echo=TRUE}
ds$f.gender <- factor(ds$gender)
```

__Reminder:__ The $ sign instructs R what data set to draw the variable from, or to tell R what data set to assign the new factored variable to. The new factored variable can be described via the _table()_ function.

```{r fac2, echo=TRUE}
table(ds$f.gender)
```

While this factored variable is split into two categories, it is not apparent which numbers represent male and female. Labels should be assigned to the numbers to clarify the relationship between the numbers and their meaning. When factoring a variable, R requires the number of levels within the variable and the corresponding labels. In the _f.gender_ variable there are two levels, 0 and 1, that require men and women labels.

```{r fac3, echo=TRUE}
ds$f.gender <- factor(ds$gender, levels = c(0,1), labels = c("Women", "Men"))
table(ds$f.gender)
```

The vector function, _c()_, instructs R the levels and labels of the variable.

The _f.party_ variable should also be factored, where 1 = Dem, 2 = Rep, 3 = Ind, and 4 = Other, then create a table of the variable.

```{r fac4, echo=TRUE}
ds$f.party <- factor(ds$party, levels = c(1,2,3,4), labels = c("Dem", "Rep", "Ind", "Other"))
table(ds$f.party)
```

The structure of the _f.party_ variable describes a factor with four levels.

```{r fac5, echo=TRUE}
str(ds$f.party)
```

There are other types of data conversions as well. In most cases, the basic syntax is the same as the _factor()_ function, except the function names are _numeric()_ or _integer()_. __Note:__ For most purposes, numeric and integer are the same.

### Coerce Factoring

Sometimes the typical commands do not work and variables must be coerced. When a variabled is coerced, R is instructed to treat the variable as if it were a different object type. The coercive functions are:

1. _as.factor()_
2. _as.numeric()_
3. _as.integer()_

__Try it!__ Convert a factor variable into a numeric variable using the _numeric()_ function.

```{r num, echo=TRUE}

```

This fails, so the coerce function should be employed.

```{r num2, echo=TRUE}
ds$n.party <- as.numeric(ds$f.party)
```

Examine the new variable with the _table()_ and _str()_ functions.

```{r num3, echo=TRUE}
table(ds$n.party)
str(ds$n.party)
```

## Part II: Recoding

In R, the _recode()_ function reassigns values to a variable. There are several broad purposes to recode a variable, including:

1. To correct or change incorrect data
2. To restructure the data, making it easier for calculations
3. To emphasize some intended effect.

One example situation in which you would want to recode would be if you wanted to look at age groups instead of exact ages. If everyone in your survey reported their exact age (e.g. 54, 23, etc.) but you wanted to break down your data by age groups, like 18-25, 26-35, etc. the recode function would be the one to use.  

To perform a recode, follow this basic syntax:

recoded.variable <- recode(old.variable, "recode commands")

Let's make it more clear by perfoming a recode. Similar to how we put "f." before a factored variable to remind us that it is factored, let's put "r." in front of our new recoded variable to remind us it is a recoded version of an already existing variable.

Let's recode the ideology variable in our class data set. Currently the ideology variable goes from 1 to 7, with 1 being very liberal and 7 being very conservative. Let's simplify the variable by recoding it into three levels, instead of the current 7. Broadly we will have a liberal level, a moderate level, and a conservative level. Let's do a recode that sorts everyone who answered 1 or 2 into 1 level, everyone from 3 to 5 into another, and 6 to 7 into a third. We primarily use the recode function from the car package.

```{r recode1, echo=TRUE}

ds$r.ideol <- car::recode(ds$ideol, "1:2=1; 3:5=2; 6:7=3; else=NA; NA=NA")

```


Let's use the table() function to look at the new recoded variable:

```{r recode2, echo=TRUE}
table(ds$r.ideol, useNA = "always")
```

Notice how we include "else=NA; NA=NA" at the end of the recode function. This tells R to regard any other responses, whether missing data or data that for some reason is outside the original range, as NA, and to treat all existing NAs as NAs. Sometimes you also need to include "-99=-99" or "-99=NA" in the function as well. 

A couple other notes about the syntax: in the recode function, you put all the recode arguments **inside one set of quotation marks**. Because of this, you need to separate each argument with a semicolon. If you try to use a comma, R will give you an error message. 

You can also save quite a bit of time by using a colon to tell R a range of values. In our recode function we put "1:2=1" meaning all values from 1 to 2 will be assigned a one. This is a preferred method over typing "1=1;2=1;etc."

There is not a set in stone way you should break down or categorize your data in a recode. Let your research question, your model design, and ultimately your data itself determine how you should do recodes. For example, if you asked a question on a survey about how much individuals support something one a scale of 1 to 4, which 1 being very supportive and 4 being not supportive, you might want to consider recoding that variable so that higher values equal more support. 

Now let's look at our race variable:

```{r race, echo=TRUE}
table(ds$race)
```

In this survey, 1 indicates white, 2 indicates African-American, and 3 through 7 indiciate a variety of other options (Native American, Asian, Pacific Islander, 2+ races, and Other).

Try recoding this variable to go from 7 levels to 3, where 1 is still white, 2 is African American, and 3 includes all others. 

```{r race2, echo=TRUE}
ds$r.race <- car::recode(ds$race, "1=1; 2=2; 3:7=3; else=NA; NA=NA")
table(ds$r.race)
```

### Factoring and Recoding

Now let's combine our knowledge of factoring and recoding. Let's factor our newly recoded race variable to apply the labels to the three levels that currently exist. Remember, 1 indicates white, 2 indicates African American, and 3 indicates another race. 

```{r race3, echo=TRUE}
ds$f.race.2 <- factor(ds$r.race, levels = c(1,2,3), labels = c("White", "African-American", "Other"))
table(ds$f.race.2)
```

Now let's do the same with our recoded ideology variable, where 1 indicates liberal, 2 is moderate, and 3 is conservative.

```{r ideol, echo=TRUE}
ds$f.ideol <- factor(ds$r.ideol, levels = c(1,2,3), labels = c("Liberal", "Moderate", "Conservative"))
table(ds$f.ideol)
```

### Creating a Dummy Variable

One reason that you might want to use your knowledge of both factoring and recoding would be to create a dummy variable. A dummy variable is a binary indicator (0 or 1) of some category, so that we can see if there is an effect from that particular category versus the rest. Dummy variables are used a lot in political science, so it is important that we understand how to create them. 

Let's create a dummy variable from our newly recoded race variable for being African American. Recall that in our recoded race variable, 2 indicates African American. For this dummy variable, we want to make African American be 1, with everyone else being 0.

```{r dummy1, echo=TRUE}
ds$r.AfAm <- car::recode(ds$r.race, "2=1; else=0; NA=NA")
table(ds$r.AfAm)
```

Now let's factor the variable to apply labels to the already existing levels of 0 and 1.

```{r dummy2, echo=TRUE}
ds$f.AfAm <- factor(ds$r.AfAm, levels=c(0,1), labels = c("Non African-American", "African-American"))
table(ds$f.AfAm)
```


## Part III: Building and Sorting Your Data


In R, you have the option of building your data within the program itself. There are a variety of ways to do this, and we will go over the basics here. 

The first function you need to know is the rnorm() function. This function allows us to generate normally-distributed random values within a given range, with specified means and standard deviations (more on that later in the class!)

Let's build some random data here:

```{r norm, echo=TRUE}
one <- rnorm(100, mean=3)
two <- rnorm(100, mean=7)
three <- rnorm(100, mean=1)
```

We just created three elements (one, two, and three) that contain 100 random values with different means. Now let's combine the three elements into columns, To do this we use the cbind() function. Let's put the three elements into a column with the label "four":

```{r cbind, echo=TRUE}
four <- cbind(one, two, three)
```

Now let's put the three elements into *rows*. We do this with the rbind() function. Let's create the rows in a new object labelled "five":

```{r rbind, echo=TRUE}
five <- rbind(one, two, three)
```


### Apply functions

In R there is a family of apply() functions. These functions give us a way of sorting through and examining our data. Let's use the apply() function to look through the data we just created. Here is the basic syntax:

apply(X, margin, fun...)

Basically this is telling R to use the apply function, on a particular object, by a particular margin (1 for rows and 2 for colums), and to use a particular function (mean, sum, etc.)

Let's use the apply function on our object "four". The object "four" is a combination of columns, so the margin equals 2. Let's look at the mean of each column in "four":

```{r apply1, echo=TRUE}
apply(four, 2, mean)
```

We just used the apply() function to tell R to report the mean value of each column. 

Now let's use the apply() function on a combination of rows. Our object "five" is a combination of rows, so let's use that. Within the apply() function, we specify that we want to look at rows by indicating that the margin is 1. Let's find the mean of all the rows:

```{r apply2, echo=TRUE}
apply(five, 1, mean)
```

Notice that these are the same values as the ones found in the earlier apply() function. This is because we assigned the same elements to "four" and "five".

There are other functions in the apply() family. For a great tutorial on the whole group visit:

https://www.datacamp.com/community/tutorials/r-tutorial-apply-family

However, let's take a look at only two more of the apply functions, sapply() and tapply().

Let's create an object, "six", that contains two lists, "a" and "b", with specified values:

```{r sapply1, echo=TRUE}
six <- list(a=1:10, b=11:20)
```

Now let's use the sapply() function to tell R to give us the mean of each list:

```{r sapply2, echo=TRUE}
sapply(six, mean)
```

The sapply() function is useful because it can be used on vectors and matrices.

Now let's look at the tapply() function. The tapply() function allows us explore data by specific parameters. Let's switch over to using our class data set. Here we will use tapply() to explore the breakdown of age and ideology within our class data set. 

```{r tapply, echo=TRUE}
tapply(ds$age, ds$ideol, summary)
```

Notice that we inlcuded the "summary" command at the end. This returned a lot of information about ideology and age. We can be more specific, like asking R to tell us only the mean age of each ideology score:

```{r tapply2, echo=TRUE}
tapply(ds$age, ds$ideol, mean)
```

### Other Methods of Exploring Your Data

Something important to know about R is that there are often many different ways to do a single obejctive. For example, we just used the tapply() function to look at the breakdown of ideolgoy by age. However, we can also use the by() function. The syntax is for by() is very similar to tapply(), so let's try it:

```{r by1, echo=TRUE}
by(ds$age, ds$ideol, summary)
```

Notice how the results are essentially the same. Now let's use by() to examine a different relationship, age and gender. We wil now tell R to give us the mean age of each gender:

```{r by2, echo=TRUE}
by(ds$age, ds$gend, mean)
```

Did you forget which value corresponds with each gender? Let's remind ourselves by using the factored gender variable:

```{r by3, echo=TRUE}
by(ds$age, ds$f.gend, mean)
```

Let's now turn to other methods of exploring your data. The filter function allows you to filter out all the data except what meets the specific parameters you specify. Let's imagine that we want to only look at the data for men. We can use the filter() function to do so. The basic syntax follows this format:

filter(data, parameter1, parameter2, etc.)

We'll want to be sure to create specific names for the objects we assign the filters to. Let's now filter so that we will only look at the men in our class data set. Let's name the new data "ds.men"

```{r filter1, echo=TRUE}
ds.men <- filter(ds, ds$gender==1)
```

Now let's imagine we want to only look at men over 30 years old. The filter function allows us to specify multiple parameters. All we need to do is tell R is filter us the data for men and, and more specifically men over 30.

```{r filter2, echo=TRUE}
ds.men30 <- filter(ds, ds$gender==1 & ds$age > 30)
```

What if you wanted to look at a breakdown of this new dataset by ideology? You'd use the summary() function we've been using:

```{r filter3, echo=TRUE}
summary(ds.men30$ideol)
```

Another way we can filter our data is by using the slice() function. This allows us to filter the data by rows. For example, let's say you wanted to look at only the first 100 rows of our class data set:

```{r slice1, echo=TRUE}
ds100 <- slice(ds, 1:100)
```

From here you would treat ds100 like you would any dataset!

### Subsetting Your Data

Another way you can breakdown your data is by subsetting it. This is similar to the way we use the filter() function. One difference is that the subset() argument comes in base R, whereas you have to make sure you have dplyr loaded to use filter(). Let's start by subsetting the data to only men:

```{r subset, echo=TRUE}
men.ds <- subset(ds, gender==1)
```

From here you would use men.ds just like any other data set. 

We can also subset the data by selecting specific columns, by both names and numbers:

```{r subset2, echo=TRUE}
ds.sub1 <- subset(ds, select = c(party:glbcc_risk))
ds.sub2 <- subset(ds, select = c(1:15))
```

You can also subset by selecting specific variables.

You can largely set whatever parameters you need by following the operator functions in R:

1. <  less than 
2. <= less than or equal to 
3. >  greater than 
4. >= greater than or equal to 
5. == exactly equal to 
6. != not equal to 
7. !	 not  (example: !x - pronounced "not x" )
8. |	 Or  (example: x | y - pronounced "x OR y") 
9. &	And (example: x & y - pronounced "x AND y") 

## Part IV: Working with Nominal Data

Often times we have to work with nominal data. This is data that does not necessarily have a numeric value, but rather is categorized by a word or label. Think political party. Let's take a look at our factored party variable:

```{r nom1, echo=TRUE}
table(ds$f.party)
```

If we were analyzing this data, the "Other" category might not tell us much. Let's create a new variable that excludes the "Other" responses. We'll do this by recoding the factored party variable to count the "Other" responses as NAs

```{r nom2, echo=TRUE}
ds$f.party.2 <- car::recode(ds$f.party, "'Dem'='Dem'; 'Rep'='Rep' ;'Ind'='Ind' ;'Other'=NA;
                            else=NA;NA=NA")
table(ds$f.party.2)
```

Notice that when we recode a factored variable, we need to put the label names in apostrophe? marks *within the quotation marks*.

### Finding the Mode

When working with nominal data, there are some statistical methods that don't make any intuitive sense. For example, if we were looking at our new factored political party variable, we couldn't find the mean, because that wouldn't make any sense. However, we could find the mode. Recall from mathematics that the mode is the value, or in this case the label, that occurs the most often in a group of values or labels. 

In R, we can find the mode using the "modeest" package, which we should have installed and loaded at the beginning of the lab. Within the package we use the mlv() function. It is important to note that the mlv() package does not work for factored variables. This might seem counterintuitive, but there are easy ways to get around it. What we have to do is tell R to think of the factored variable as if it were numeric, or an integer. In this case, we will use the as.integer command to do so:

```{r mode1,echo=TRUE}
mlv(as.integer(ds$f.party.2), na.rm = TRUE)
```

After running this test we see that the mode is 3. In order to check which nominal label corresponds with 3, we can simply print out a table of the factored variable:

```{r mode2, echo=TRUE}
table(ds$f.party.2)
```

Here we see that 3 corresponds with Republican, so Republican is the most frequent value. 

Another method we can use to find the mode is to make a table, and sort the table by how often the labels occur. 

```{r mode3, echo=TRUE}
sort(table(ds$f.party.2), decreasing = TRUE)
```

Here we see the same result, but found it using a different method.

We can also use the freq() function to look at the frequency:

```{r freq, echo=TRUE}
freq(ds$f.party.2, plot = FALSE)
```

This gives us how many are in each group, but also the percentages. If we wanted to construct a table that shows the percentage breakdown only, we would first create a table of the variable, then use prop.table(), then multiply by 100.

```{r prop, echo=TRUE}
party.table <- table(ds$f.party.2)
party.table.per <- prop.table(party.table)*100
party.table.per
```

### Visualizing Nominal Data

Now let's venture into some early and simple visualizations. R has nearly countless ways to visualize data, but let's start with a really simple method: a barplot. 

Barplots are great for visualizing nominal data. When creating a barplot, you first use the barplot() function, and then specify the object that you want visualized. Let's visualize the table of our political party breakdown:

```{r bar1, echo=TRUE}
barplot(table(ds$f.party.2))
```

Instead of having to type "table(ds$f.party.2)" inside the barplot function, we could use the party.table object we created earlier. Let's do that, but this time add a legend and some color:

```{r bar2, echo=TRUE}
barplot(party.table, beside=TRUE, legend=rownames(party.table), col = c("Blue", "White", "Red"),
        ylab ="Frequency", main="Frequency of Respondents by Political Party")
```

The specific syntax needed to customize visualiztions will get easier with time.

Remember the table we created that shows the percentage breakdown of the parties? Let's visualize that this time:

```{r bar3, echo=TRUE}
barplot(party.table.per, beside=TRUE, legend=rownames(party.table.per), col = c("Blue", "White", "Red"),
        ylab ="Percentage", main="Percentage of Respondents by Political Party")
```


## Part V: Working with Ordinal Data

Recall that ordinal data is data that is assigned numeric values, but on an ordered scale. One very intuitive type of ordinal data is educaton level. Edcation level is on an ordered scale: some high school is higher than no high school, a high school diploma is higher than some high school, some college is higher than high school, etc. 

Let's use the education variable in our class data set to explore how to work with ordinal data. First let's look at a table of the education variable:

```{r ord, echo=TRUE}
table(ds$education)
```

We can see that there are 8 categories in the ordered scale, but we aren't displaying what levels of education they are. Let's factor the variable to do so:

```{r ord2, echo=TRUE}
ds$f.education <- factor(ds$education, levels=c(1,2,3,4,5,6,7,8), 
                   labels=c("< HS","HS/GED","Vocational/Technical", "Some College",
                            "2 year/Associates", "Bachelor's Degree", "Master's degree", "PhD/JD/MD")) 
table(ds$f.education, useNA = "always")
```

Let's practice finding the mode of education:

```{r ord3, echo=TRUE}
sort(table(ds$f.education), decreasing = TRUE)
```

Now let's visualize our education data:

```{r ord4, echo=TRUE}
barplot(table(ds$f.education))
```

Now let's create a table object for the education data and create a new visualization with some more detail:

```{r ord5, echo=TRUE}
educ.table <- table(ds$f.education)
barplot(educ.table, beside=TRUE, legend=rownames(educ.table), 
        col = c("#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd"),
        ylab ="Frequency", main="Frequency of Respondents by Education Level", 
        args.legend = list(title = "Education", x = "topright", cex = .7), ylim = c(0, 700))
```

Those colors listed are hexadecimal colors, which R recognizes. You can check out color schemes here:

http://colorbrewer2.org/

## Part VI: Working with Interval Data

Interval data is similar to ordinal data, but with interval data the difference between levels does have some intuitive value to it. For this section we will use an ordinal measure, but treat it as if it is interval. In our class data set we have a variable that measures an individual's perception of the risk posed by global climate chage, glbcc_risk, on a scale of 0 being no risk to 10 being extreme risk. 

Within the "psych" package, there is a function called "describe". Let's use the describe() function to examine the variable:

```{r int, echo=TRUE}
describe(ds$glbcc_risk)
```

Now let's find the mode:

```{r int2, echo=TRUE}
mlv(ds$glbcc_risk, na.rm = TRUE)
```

As we can see, the most frequent value is 10. 

When visualizing interval data, it is more appropriate to use a histogram instead of a barplot. This is because a histogram displays values on a continuous scale, not individual values separated from others. Let's make a histogram using the hist() function.

```{r hist, echo=TRUE}
hist(ds$glbcc_risk)
```

Now let's look at the density of the variable. To do this, we need to remove all missing values from the variable. The na.omit() fuction does this. Then we tell R to plot the density.

```{r dens, echo=TRUE}
density.gcc <- density(na.omit(ds$glbcc_risk))
plot(density.gcc)
```

We can also do this by using the densityPlot function in the "car" package. Again, we need to make sure the NAs are ommitted. First we will do the basic plot, and then we'll adjust the bandwitdth.

```{r dens2, echo=TRUE}
densityPlot(na.omit(ds$glbcc_risk))
densityPlot(na.omit(ds$glbcc_risk), adjust = 25)
```

Now let's create a boxplot of the variable, which is a different way to look at it:

```{r box, echo=TRUE}
boxplot(ds$glbcc_risk, xlab = "GCC Risk", main = "Percieved Risk of Global Climate Change")
```
